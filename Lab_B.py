# -*- coding: utf-8 -*-
"""LAB_B_HT19-1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Z8WFvGpboKKduMuMkTeMDkINs3h1TVAL

# DT1130 LAB B - Bildbehandling

I den här laborationen kommer du att få experimentera med enkel linjär
bildbehanding i Python. Du kommer att få bygga upp ett filter från
grunden och sedan testa olika filter med avseende på prestanda och
resultat.

### Hjälp och redovisning
För att få hjälp under labpasset, använd [Queue-systemet](http://queue.csc.kth.se/#/queue/DT1130) för att tillkalla Labassistent. För att få hjälp övrig tid, skriv ett inlägg under [Hjälp på Canvas](
  https://kth.instructure.com/courses/12513/discussion_topics/84209
  ).

När du är klar med labben behöver du göra två saker:
* Redovisa för en labassistent under ett labpass (använd [Queue-systemet](http://queue.csc.kth.se/#/queue/DT1130) för att meddela att du är klar att redovisa)
* Lämna in din lab som **.ipynb**-fil i Canvas (Ladda ner från Colab med **File | Download .ipynb**)

## Innan vi börjar
Det första man ska göra är att spara en egen kopia av detta labbpek då detta är skrivskyddat. Detta gör man antingen genom att klicka på open in playground eller *File* -> *Save a copy in drive*.

### Ladda in lite data

Hämta paketet med [labdata](https://www.dropbox.com/s/yniqir9ox6l751z/labdata.zip?dl=0) om du inte redan gjort det. Det innehåller bl.a. bilder som du kan använda för att testa dina filter. Ladda in dem i Colab (Se [jobba med filer](https://colab.research.google.com/drive/1LoIS5JzeupGVf6a4-A0sBxAeOnxzdXW8?authuser=1#scrollTo=bmTBuKQMRoa_) i labintroduktionen)

# Introduktion


Filter i 2D kan användas för många ändamål:
- lågpassfilter kan användas för att göra bilder oskarpa, reducera högfrekvent brus eller när man vill skala om en bild (omsampling). 
- högpassfilter kan användas för att detektera kanter i bilden eller förhöja skärpan, mm. 

### Linjär bildbehandling och faltning i 2D

Inom bildbehandling är faltning (eng.convolution ) en av de vanligaste operationerna. En faltning kan ses som
en summa av förskjutna versioner av en signal/bild där varje term är
multiplicerad med en koeffcient - dessa koefficienter utgör impulssvaret , eller
filterkärnan som det ofta benämns i bildsammanhang. Notera att vid faltning i 2D
är oftast impulssvaret/kärnan centrerat kring origo, emedan endimensionella
filter för ljudsignaler ofta har sin början i origo.

##Faltning i 2D

Den generella formen för faltning i två dimensioner ges av uttrycket

$$
Y(u,v) = X(u,v) \ast
H(u,v)=\sum_{s=-\infty}^{\infty}\sum_{t=-\infty}^{\infty}
{H(s,t)X(u-s,v-t)}
$$

Figuren nedan visar hur faltning i 2D går till i praktiken
genom att låta kärnan $H$ rulla över bilden $X$.

![Faltning](https://drive.google.com/uc?export=download&id=1Qk8_D7X8iXqB-Y8ugv2iUeTIWKPwXcce)



Faltning i två dimensioner, steg för steg. Kärnan $H$ faltas med bilden $X$ vilket resulterar i $Y$. Elementen i $Y$ beräknas ett i taget: kärnan centreras över det första elementet i $X$ och elementen i $H$ och $X$ multipliceras och summeras till det första elementet i $Y$. Proceduren upprepas tills alla element i $Y$ har beräknats.

## Bildbehandling i python

Först börjar vi med att importera de bibliotek som vi kommer att använda.
"""

import matplotlib.pyplot as plt
import numpy as np
import scipy
import scipy.signal
import imageio

"""### Exempel"""

# Exempel

# Vi vill skapa en randomiserad färgbild och här definierar vi dimensionerna
M = 50  # Rader / Höjd
N = 75  # kolumner / Bredd
C = 3  # Färgkanaler (RGB)

"""#### Angående datatyp för bilder

Bilder användas och processeras vanligtvis i två olika dataformat


* som "unsigned integer": **uint8**, för heltal [0, 255]. `imageio.imread()` returnerar normalt en array av typen **uint8** (eftersom det motsvarar hur bilddata lagras i filen). 
* som flyttal: **float64**,  för värden [0, 1]. Detta är datatypen för "*vanliga*" matriser i numpy.

När vi ska göra beräkningar och bildbehandling passar det bättre att använda **float64** dvs flyttal mellan [0 .. 1]. 

Datatypen påverkar även hur `plt.imshow()` beter sig. Ur dokumentationen för [matplotlib.pyplot.imshow()](https://matplotlib.org/api/_as_gen/matplotlib.pyplot.imshow.html):

  * " *The RGB(A) values should be in the range [0 .. 1] for floats or [0 .. 255] for integers. Out-of-range values will be clipped to these bounds.*"

* För att ändra datatyp på en matris använder man metoden `.astype()`. Exempel: `A.astype('float64')` gör om typen på **A** till **float64**.
"""

# Här skapas en bild med datatypen unsigned integer np.uint8
total_pixel_count = M * N * C  # 3 color channels
im = np.random.randint(0, 256, total_pixel_count, dtype=np.uint8)  # randomiserade pixelvärden 

#print(im)
# np.random.randint tar endast in lägre gräns, över gräns och antal värden
# därför måste vi "forma om" antalet pixlar till dimensiorna vi vill åt.
im = im.reshape(M, N, 3)


# "Känn" gärna på datan. Testa att se vilka dimensioner matrisen 
# har, största/lägsta värdet, medelvärdet, värdet för en specific pixel etc.
#print(im)
print('shape: ', im.shape)
print('max: ', im.max())
print('min: ', im.min())
print('mean: ', im.mean())
print('im[0,0]: ', im[0,0])  # Hur många värden finns i pixel 0,0 ? Varför?

# Använd plt.imshow för att plotta bilden

plt.imshow(im)  # bilden skapas
plt.title('Random Colored Image')  # Bildtitel
plt.show()  # bilden visas

"""#### Den andra datatypen som är vanligt att använda är floats (np.float64)

Om bilden processeras av denna datatyp ska värdena vara mellan 0 och 1
"""

# Här skapas en bild med floats med värden mellan 0 och 1

np.random.rand?
im = np.random.rand(M, N, C)  # randomiserad färgbild

# OBS: Lägg märke till att vi skriver över variabeln "im" här


# "Känn" gärna på datan. Testa att se vilka dimensioner matrisen 
# har, största/lägsta värdet, medelvärdet, värdet för en specific pixel etc.

print('shape: ', im.shape)
print('max: ', im.max())
print('min: ', im.min())
print('mean: ', im.mean())
print('im[0,0]: ', im[0,0])  # Hur många värden finns i pixel 0,0 ? Varför?

# Använd plt.imshow för att plotta bilden

plt.imshow(im)  # bilden skapas
plt.title('Random Colored Image')  # Bildtitel
plt.show()  # bilden visas

"""#### För numpy arrays så kan ni se vilken typ er data är genom att printa, för vårt exempel "im.dtype" för att se vilken datatyp datan är lagrad som.

Detta kan vara bra att kolla om det inte går att visa bilden eller om något inte verkar fungera som det ska.
"""

print("Datatyp: ", im.dtype)

"""## Färg till gråskala

Svartvit bild fås genom att till exempel ta medelvärdet av färgerna i färgkanalerna.

* Beräkna medelvärdet i axis=2. 
* Axis=0 är rader, axis=1 är kolumner och axis=2 är färgkanalerna

Den läser de
flesta format och returnerar en matris av pixelvärden mellan 0 och 255.  Färgbilder
returneras som en $M \times N \times 3$-matris.  Dessa kan konverteras till en vanlig
2D-gråskalematris genom att ta medelvärdet av de tre färgplanen.
"""

# beräkna medelvärdet i axis=2
mean_img = np.mean(im, axis=2)

print("mean_img shape:", mean_img.shape)  # Varför har datan dessa dimensioner?


# Plotta bilden
plt.imshow(mean_img, cmap='gray')  # Lägg märke till colormapen, cmap='gray'. Testa gärna utan!
plt.title('Gray Version')
plt.show()

"""### Visa flera bilder med plt.subplot

Om man vill visa mer än en bild i en och samma figur är `plt.sublot` en värdefull funktion att använda.

Nedan följer ett kort exempel.
"""

# Exempel på plt.subplot

im1 = np.random.rand(M, N, 3)
im2 = np.mean(im1, axis=2)

# De första två siffrorna i subplot avgör hur "the grid" ska vara definierat
# Den sista siffran är för vilken plats (från vänster till höger, uupifrån och ned)
# det nästkommande plotten ska vara.

# Som vanligt så är det fördelaktigt att testa sig runt. 
# Kod kan köras hur många gånger som helst!

plt.subplot(1,2,1)  # 1 rad, 2 kolumner, plats 1
plt.imshow(im1)
plt.title('Första bilden')

plt.subplot(1,2,2)  # 1 rad, 2 kolumner, plats 2
plt.imshow(im2)
plt.title('Andra bilden')

plt.show()  # visa bilderna

"""## Uppgift 1: läs in en bild och gör den lite oskarp

Välj ut en bildfil som du vill jobba med (i första uppgiften blir det tydligast om du väljer lågupplöst bild t.ex. **uggla2.tif** ). Om du inte gjort så redan, så ladda upp filen till denna colab genom att, till vänster i menyn, välja tabben "Files" och trycka på "UPLOAD".  Då bilden har laddats upp ska den läsas in så vi kan processera den. 

* Läs in bilden till matrisen $I$.

För att läsa in en bild använder du funktionen `imageio.imread()`.
"""

# Detta är bara ett kodskal och allt här kan/får ändras.

# Ladda in en bild
# OBS: byt ut namnet i imread() till filen ni laddade upp
I = imageio.imread('uggla2.tif')  # Detta kan producera varningar som ni inte behöver bry er om


# OBS: Lägg märke till datatypen som returnerades och dimensionerna
# Är bilden i färg eller i gråskala? Hur ser man det från I.shape?
print('Datatyp: ', I.dtype)
print('Dimensioner: ', I.shape)

# Plotta bilden och se att allt står rätt till
plt.imshow(I, cmap='gray')
plt.title('My image')
plt.show()

"""### OBS: För första övningen använd en bild i gråskala (gör om eventuell färgbild till gråskala)"""

# Vi följer rekommendationerna och gör om datan i bilden till floats
# och normaliserar till värden mellan 0 och ett
I = I.astype('float64')

print('Datatyp: ', I.dtype)

# OBS: Om ni laddade in en färgbild så lägg till kod här som gör om bilden till gråskala

"""## Faltning

Nu när ni har en bild i gråskala och av datatypen "float" mellan 0 och 1 så ska ni implementera faltning (med hjälp av for-loopar) enligt principen i figuren/ekvationen i föregående sektion **Faltning i 2D**.

Som en första övning är målet att implementera en faltning över matrisen **I** men en $3x3$ rullande-**medelvärdeskärna**. 

$$ H =
\frac{1}{9}\left[
  \begin{array}{ccc}
    1 & 1 & 1 \\
    1 & 1 & 1 \\
    1 & 1 & 1
  \end{array}
  \right]
$$

Plotta sedan originalbild och den filtrerade bilden sida vid sida med hjälp av `plt.subplots`.

(Varför multipliceras matrisen med ettor men $\frac{1}{9}$ ?)

### Hantering av kanter

Som ni kanske kommer ihåg från lab1 så kan det vara finurligt att veta vad man ska göra i kanterna av en signal/bild vid faltning.

**Det finns olika sätt att hantera kanterna:**
* Ett sätt är att "strunta i" att beräkna faltningen för de värden i kanterna där filter-kernel **H** går utanför bilden. Alltså att endast göra processering en bit in i bilden. Det är okej att hantera kanterna så men då ska man veta att bilden man får ut kommer att vara mindre än bilden en filtrerar.

* Ett annat sätt är att lägga till "fiktiva" värden som en ram runt bilden. Att *pad:a*, lägga till *padding* runt bilden .Dessa värden kan, till exempel, vara **noll**, **ett** (för floats) eller bara en kopia av det värde pixeln bredvid har. Gör man detta så kan den filtrerade bilden vara lika stor som oríginal bilden.

* **Mer om detta efter första uppgiften!**

### Börja "enkelt"

För detta första exempel så kan vi göra det så "lätt som möjligt" för oss och bara strunta i att ha de yttersta värdena som center för vår filtrerings-kernel. 

Istället för att iterera genom alla rader och kolomner så itererar vi över värdena från 

* rad: 1 till $M-2$
* kolumn: 1 till $N-2$


Att vi undviker den första och sista raderna/kolumnerna är för att vi använder oss av en $3x3$-kernel
vilket innebär att vi använder oss av 1 värde till vänster/höger och 1 värde över/under.
"""

# Kernel H

H = 1/9 * np.ones((3,3))

n_rows, n_cols = I.shape  # få ut antal rader och kolomner
# Gör en ny array ni kan lägga in era beräknade värden i
new_I = np.zeros((n_rows-2, n_cols-2))  # Varför dra bort 2 ?
for i in range(new_I.shape[0]): # alla rader i nya bilden
  for j in range(new_I.shape[1]): # alla kolumner i nya
    sum = 0
    for k in range(H.shape[0]): # alla rader i H
      for m in range(H.shape[1]): # alla kolumner i H
        sum += I[i+k, j+m]*H[k, m] # tar tre värden från första, andra och tredje raden och summerar
    new_I[i, j] = sum # läggs in på rätt plats för att vi tog bort 1 kolumn och 1 rad (kolla bilden ovanför)

"""## Visualisera resultat

Använd er av plt.subplot för att visualisera faltningen. Om allt har gått rätt till borde ni ha skapat en ny bild som är en lite suddig variant av originalbilden.
"""

# Visualisera resultat

plt.subplot(1,2,1)  # 1 rad, 2 kolumner, plats 1
plt.imshow(I, cmap = "gray")
plt.title('Första bilden')

plt.subplot(1,2,2)  # 1 rad, 2 kolumner, plats 2
plt.imshow(new_I, cmap = "gray")
plt.title('Andra bilden')

plt.show()  # visa bilderna

"""## Använda redan implementerade verktyg för faltning


Ett enklare sätt att falta med python är att använda

```python
scipy.signal.convolve
scipy.signal.convolve2d
```

Läs på i scipys [dokumentation](https://docs.scipy.org/doc/scipy/reference/) om dessa funktioner,
och jämför resultatet av ditt faltningsuttryck med de inbyggda funktionerna. Vad skiljer?

### Angående gränser för faltning

I exemplet i figuren ovan har $X$ och $Y$ samma
storlek, vilket ofta är praktiskt. Det finns dock andra sätt att
hantera gränserna för faltningen. `convolve2d` kan man ange
argumentet `shape` som kan vara antingen `valid`,
`same` eller `full`. **Valid** innebär att man aldrig låter
kärnan gå utanför bildens kant. Detta resulterar i en utbild som är
mindre än inbilden. **Same** motsvarar exemplet i figuren nedan där utbilden får samma storlek som
inbilden. **Full** innebär att kärnan går över alla positioner
där det finns ett överlapp mellan inbild och kärna. De tre
varianterna illustreras i figuren nedan.

![Faltning i två dimensioner](https://drive.google.com/uc?export=download&id=1rO5bcoiXjJ9LYlxSgSNmazDYj4hn0jKO)

## Uppgift 2: mera oskärpa med Gauss-filter!

Rullande medelvärde är enkelt att implementera och applicera, men inte alltid optimalt.
Ett problem är t.ex. att filtret inte påverkar bilden lika i alla riktningar (varför
inte?). Ofta vill man också ge större inflytande åt pixlarna i mitten av kärnan än de
längs kanterna.

Ett filter som uppfyller dessa krav och ofta används för oskärpa/lågpass är gauss-filtret
där kärnan ges av den klassiska $gaussklockan$ i två dimensioner:

$$ h(x,y)=ke^{-\frac{x^2+y^2}{2\sigma^2}} $$

Där $x$ och $y$ motsvarar horisontella och vertikala
dimensionerna, samt $\sigma$ bestämmer gausklockans bredd. Förutom att detta filter
behandlar bilden lika i alla riktningar, så har det den stora fördelen att vara linjärt
separerbart i x- och y-led. Det innebär att faltningen kan delas upp i två oberoende steg.

$k$ är en konstant som ska väljas så att
filterkärnans element summerar till ett (precis som moving-average-filtret i uppgift 1).  Detta för att bildens ljusstyrka (intensitet) inte ska påverkas av filtret.  
I praktiken kan man enkelt åstadkomma detta är att dela alla filterkärnans element med
totalsumman.

Välj $\sigma = \frac{N}{6}$. (Ett praktiskt problem är ju att gauss-funktionen aldrig
riktigt blir noll, dvs man måste trunkera impulssvaret någonstans. I praktiken brukar man
i bildbehandlingstillämpningar anse att funktionen är ''tillräckligt liten'' vid avståndet
$3\sigma$ från mitten på kärnan, vilket ger $\sigma = \frac{N}{6}$.)


#### Läs in bilden `lynn-eyes-halftone.png` som 2d-matrisen $I$ för denna uppgift.
"""

# Ladda upp lynn-eyes-halftone.png och läs in.
# Läs in bilden här och spara i en variabel men gå vidare till nästa kod-cell
# för processering. Detta för att slippa läsa in bilden igen för varje gång ni
# vill testa er implementation.
# Även här rekommenderas att göra om till gråskala
img = imageio.imread('lynn-eyes-halftone.png')
print(img.shape)
img = np.mean(img, axis=2)
print(img.shape)
# Plotta bilden
plt.imshow(img, cmap="gray")
plt.title('My image',)
plt.show()

"""### a) 

Skriv en funktion för gaussisk oskärpa. Funktionen ska skapa ett gauss-filter av önskad storlek ($N$) - centrerat kring $\frac{N}{2}$ och sedan filtrera bilden $I$ med detta. Det är ok att använda t.ex. `scipy.signal.convolve` eller `scipy.signal.convolve2d` inifrån funktionen.
"""

# Fyll i koden i `gaussblur` funktionen enligt instruktionerna ovan


def gaussblur(I, N):
    """
    blur an image using a gaussian kernel
 
    input:
        I (matrix) - image to be blurred
        N (integer) - desired size of the gaussian kernel
    output:
        new_I (matrix) - blurred image
    """
    sigma = N/2 # standardavvikelsen från gaussklockans distrubition
    #k = 1/(N*N) # används så att summan av antalet element i filterkärnan blir 1
    H = np.ones((N, N)) # filterkärnan
    sum = 0
    # lägger in alla värden i filterkärnan som en funktion av positionen i H
    for x in range(H.shape[0]):
      for y in range(H.shape[1]):
        H[x, y] = np.e**((-x**2 + y**2)/(2*sigma**2))
        sum += np.e**((-x**2+ y**2)/(2*sigma**2))
    k = 1/sum
    H = H*k
    
    # använder scipys egna metod för att falta
    new_I = scipy.signal.convolve2d(I, H, mode="same", boundary="fill", fillvalue = 0)

    return new_I

"""### Visualisera resultat"""

# Originalbilden är här sparad i variabeln I
img_n_3 = gaussblur(img, 3)
img_n_15 = gaussblur(img, 15)

# Visualisera exempel med subplot. 
# Lägg märke till ett annat sätt att använda subplot. Försök gärna förstå hur
# det fungerar
f, ax = plt.subplots(3, 1)
ax[0].imshow(img, cmap='gray')
ax[1].imshow(img_n_3, cmap='gray')
ax[2].imshow(img_n_15, cmap='gray')
plt.show()

"""### b) 

Visa att gaussfiltret är linjärt separerbart! Läs i S.W.Smith, kap. 24 om separerbara filterkärnor (Convolution by separability) om du känner dig osäker. Skriv sedan en funktion för gaussisk oskärpa enligt funktionsprototypen i `gaussblur_sep` där funktionen utnyttjar separerbarheten och då gör två faltingar med en endimensionell kärna (i x- reps. y-led).
"""

# KODA HÄR

#Falting endimensionellt
def faltning_endimensionell(I, H, transposed):
  n_rows, n_cols = I.shape  # få ut antal rader och kolomner

  # Gör en ny array ni kan lägga in era beräknade värden i

  new_I = np.zeros((n_rows-int(len(H)/2)*2, n_cols-int(len(H)/2)*2)) # nya matrisen som returneras som är mindre än originalet

  for i in range(new_I.shape[0]): # alla rader i nya bilden
    for j in range(new_I.shape[1]): # alla kolumner i nya
      sum = 0
      for k in range(len(H)): # alla element i H
        if not transposed: # vertikal H
          sum += I[i, j+k]*H[k] # summerar faltade element
        else:
          sum += I[i+k, j]*H[k] # summerar faltade element
      new_I[i, j] = sum # läggs in på rätt plats för att vi tog bort x antal kolumner och x antal rader (kolla bilden ovanför)
  return new_I

# Fyll i koden i `gaussblur_sep` funktionen enligt instruktionerna ovan
def gaussblur_sep(I, N):
  """
  blur an image using a gaussian kernel

  input:
      I (matrix) - image to be blurred
      N (integer) - desired size of the gaussian kernel
  output:
      new_I (matrix) - blurred image
  """
  sigma = N/2 # standardavvikelsen från gaussklockans distrubition
  H_x = np.ones((1,N))
  sum = 0
  for x in range(H_x.shape[0]):
    H_x[0, x] = np.e**((-x**2)/(2*sigma**2))
    sum += np.e**((-x**2)/(2*sigma**2))
  k = 1/sum
  H_x=H_x*k
  new_I_x =scipy.signal.convolve2d(I, H_x, mode="same", boundary="fill", fillvalue = 0)
  
  H_y = H_x.T
  
  # använder scipys egna metod för att falta
  new_I = scipy.signal.convolve2d(new_I_x, H_y, mode="same", boundary="fill", fillvalue = 0)
  return new_I



# Originalbilden är här sparad i variabeln I
img_n_3 = gaussblur_sep(img, 3)
img_n_15 = gaussblur_sep(img, 15)

# Visualisera exempel med subplot. 
# Lägg märke till ett annat sätt att använda subplot. Försök gärna förstå hur
# det fungerar
f, ax = plt.subplots(3, 1)
ax[0].imshow(img, cmap='gray')
ax[1].imshow(img_n_3, cmap='gray')
ax[2].imshow(img_n_15, cmap='gray')
plt.show()

"""## Ta tid på implementation

För att testa hur lång tid något tar i python kan man använda sig av biblioteket `time`.

Här följer ett lätt exempel på hur några vanliga funktioner,  `time.time()` och `time.sleep()`, kan användas
"""

import time  # time biblioteket är bra för att ta tid! 


# kod som dröjer
def kod_som_tar_tid():
  for i in range(3):
    time.sleep(0.1)  # funktion som "väntar" i 0.1 sekunder'
    
    
t = time.time() # Ger tiden just nu

kod_som_tar_tid()

tid_det_tog = time.time() - t   # Ger tiden det tog att köra (tiden nu minus tiden då)

print('Det tog: ', tid_det_tog, 'sekunder')

"""--------------------------------------------

c) Testa filtret på bilden $I$ med olika storlek på kärnan, och
jämför resultaten. Jämför även tidsåtgången mellan att falta i 2d samt att använda separerbarheten.
"""

# 2D faltning med 3x3 kärna
t = time.time() # Ger tiden just nu
img_n_3 = gaussblur(img, 3)
tid_det_tog = time.time() - t   # Ger tiden det tog att köra (tiden nu minus tiden då)
print('2D faltning med 3x3 kärna. Det tog: ', tid_det_tog, 'sekunder')

# 2D faltning med 3x3 kärna
t = time.time()
img_n_15 = gaussblur(img, 15)
tid_det_tog = time.time() - t   # Ger tiden det tog att köra (tiden nu minus tiden då)
print('2D faltning med 15x15 kärna. Det tog: ', tid_det_tog, 'sekunder')

# 1D faltning med 3x3 kärna
t = time.time()
img_n_15 = gaussblur_sep(img, 3)
tid_det_tog = time.time() - t   # Ger tiden det tog att köra (tiden nu minus tiden då)
print('1D faltning med 3x3 kärna. Det tog: ', tid_det_tog, 'sekunder')

# 1D faltning med 15x15 kärna
t = time.time()
img_n_15 = gaussblur_sep(img, 15)
tid_det_tog = time.time() - t   # Ger tiden det tog att köra (tiden nu minus tiden då)
print('1D faltning med 15x15 kärna. Det tog: ', tid_det_tog, 'sekunder')

"""# Kantdetektion: Sobeloperatorn

En vanlig tillämpning av bildfilter inom bl.a. datorseende är att hitta kanter i bilden.
Det kan man göra genom att beräkna bildens **gradient** i $x$- resp. $y$-led. Den s.k.
$Sobel-operatorn$ gör detta:

$$
H_X = \left [
\begin{array}{ccc}
  -1 & 0 & 1 \\
  -2 & 0 & 2 \\
  -1 & 0 & 1
\end{array}
\right ]
\quad
H_Y = \left [
\begin{array}{ccc}
 -1 & -2 & -1 \\
 0 & 0 & 0 \\
 1 & 2 & 1
\end{array}
\right ]
$$

Om man filtrerar en bild med dessa två kärnor får man alltså gradientens $x-$ repsektive
$y$-komponenter, vi kan kalla dem $G_X$ och $G_Y$. Dessa kan kombineras för att få
gradientens belopp:

$$g_{i,j} = \sqrt{g_{x,i,j}^2 + g_{y,i,j}^2}$$

där $g_{x,i,j}$ motsvarar pixeln på rad $i$, kolumn $j$ av $G_X$.

## Uppgift 3: sobeloperatorn

Beräkna gradienterna $G_X$, $G_Y$ samt beloppet $G$ enligt ovan för bilden
`terracotta-wall.jpg`, och plotta sida vid sida. Studera och kommentera.

Använd gärna `plt.subplots` och namnge bilderna med relevanta titlar.
"""

# Ladda upp och läs in terracotta-wall.jpg
img = imageio.imread('teracotta-wall.jpg')
img = np.mean(img, axis=2)

# Plotta gradienterna
Hx = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]
Hy = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]]

Gx = scipy.signal.convolve2d(img, Hx, mode="same", boundary="fill", fillvalue = 0)
Gy = scipy.signal.convolve2d(img, Hy, mode="same", boundary="fill", fillvalue = 0)

G = np.zeros((img.shape[0], img.shape[1]))

for i in range(G.shape[0]):
  for j in range(G.shape[1]):
    G[i, j] = np.sqrt(Gx[i, j]**2 + Gy[i, j]**2)

plt.subplot(2,1,1)  # 1 rad, 2 kolumner, plats 1
plt.imshow(img, cmap = "gray")
plt.title('Första bilden')

plt.subplot(2,1,2)  # 1 rad, 2 kolumner, plats 2
plt.imshow(G, cmap = "gray")
plt.title('Andra bilden')

plt.show()  # visa bilderna

#Det verkar som att den nya bilden visar den största kontrastskillnaden i bilden.

"""## Uppgift 4: högpassfilter

Ett sätt att se på ett högpassfilter är som motsatsen till ett lågpassfilter. Dvs det
släpper igenom allt det lågpassfiltret stoppar och tvärt om. Detta faktum kan vi utnyttja
för att "bygga om" ett lågpassfilter till ett högpass. Om vi tar skillnaden mellan en
bild och den lågpassfiltrerade versionen av samma bild så borde det som blir kvar vara
"högpass-delen". För att det ska fungera krävs att lågpasskärnans alla element summerar
exakt till ett. Skriv några python-rader som högpassfiltrerar en bild på detta sätt
baserat på $gauss$-oskärpefiltret du gjorde i uppgift 2!

Notera: Subtraktionen mellan originalbild kan även implementeras direkt i filterkärnan. Då
kommer filterkärnan summeras till noll. Alltså: för lågpass summerar filterkärnan till
$ett$ och för högpass till $noll$. Hur kan detta tolkas/förklaras i
*frekvensdomänen*?

**att redovisa: kod, bilder och kommentarer**
"""

# KOD FÖR HÖGPASSFILTER HÄR
img = imageio.imread('teracotta-wall.jpg')
img = np.mean(img, axis=2)

lågpass = gaussblur(img, 15)
högpass = img-lågpass

plt.imshow(högpass, cmap = "gray")
plt.title('Högpass')

# när det blir en plötslig ändring av intensitet så är det hög frekvent och det är detta som vi ser i bilden
# kanterna blir skarpa linjer där det är en snabb skillnad i intensitet. Där den går mellan vitt till grått till svart så
#är det inte lika hög frekvens

"""## Uppgift 5 (frivillig): Filtrering i frekvensdomänen

Nu ska du pröva att göra samma sak i frekvensdomänen. Kom ihåg faltningsteoremet: en
faltning i spatial-domänen motsvarar en multiplikation i frekvensdomänen. Det handlar
alltså om att transformera bilden till frekvensdomänen med hjälp av FFT (Fast fourier
transform)  - för bilder kan man använda numpy-kommandot `np.fft.fft2()` -
multiplicera med filtrets frekvensdomänsrepresentation och sedan transformera tillbaka.


Det finns ett användbart numpykommando som heter `np.fft.fftshift()`. Det möblerar om lite
i resultatet från FFT:n så att frekvensen noll hamnar i mitten och höga frekvenser utåt
kanterna, istället för noll vid kanterna och höga frekvenser  i mitten. Det blir mer
intuitivt så. Börja med att transformera en bild med `np.fft.fftshift(np.fft.fft2(I))` och
studera resultatet med `plt.imshow`. Det är en komplex matris så du behöver ta beloppet
eller realdelen för att kunna visa den som en bild. Använd därefter `np.log` på
resultatet.


För att få filterkärnans frekvensrepresentation kan man förstås också använda FFT, men här
ska vi istället direkt specificera hur filtret ska se ut i frekvensdomänen, och tillämpa
maskning, dvs sätta vissa frekvensområden till noll. Bestäm en radie (ett lämpligt
utgånsvärde kan vara t.ex. 20) - det är filtrets brytfrekvens. Frekvensskalan utgår från
bildens mitt, så ett lågpassfilter fås genom att sätta alla punkter som ligger utanför
radien till noll. För ett högpassfilter gäller det omvända.

Resultatet av maskningen transformeras sedan tillbaka till
spatialdomänen med `np.fft.ifft2(np.fft.fftshift())`. Resultatet kommer vara
en komplex matris, så du behöver ta realdelen för att kunna visa den
som bild.

Plotta originalbild och filtrerad bild sida vid sida. Testa både
högpass och lågpass för olika brytfrekvenser.
"""

# KOD FÖR FREKVENSDOMÄNSFILTRERING
img = imageio.imread('teracotta-wall.jpg')
img = np.mean(img, axis=2)
img_fft = np.fft.fftshift(np.fft.fft2(img))

plt.imshow(np.log(abs(img_fft)), cmap = "gray")
#plt.title('Shifted FFT Transform')
print(img_fft.dtype)
#def filter_inside_fft_domain():


mittx = img_fft.shape[0]//2
mitty = img_fft.shape[1]//2
radie = 20
y,x = np.ogrid[-mittx: img_fft.shape[0]-mittx, -mitty: img_fft.shape[1]-mitty]
mask = x**2+y**2 >= radie**2 # större än radie = lågpass, mindre än radie = högpass
img_fft[mask] = 0

img_refft = np.fft.ifft2(np.fft.fftshift(img_fft))
plt.subplot(2,1,1)  # 1 rad, 2 kolumner, plats 1
plt.imshow(img, cmap = "gray")
plt.title('Första bilden')

plt.subplot(2,1,2)  # 1 rad, 2 kolumner, plats 2
plt.imshow(img_refft.real, cmap = "gray")
plt.title('Andra bilden')
plt.show()

