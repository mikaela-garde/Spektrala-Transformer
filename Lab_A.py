# -*- coding: utf-8 -*-
"""LAB_A-Erik-M-och-Mikaela-G.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SewO4afII7-Qtgs62CRGU7aVWPfXTsPQ

#DT1130 LAB A - Faltning och filtrering (1D)

I denna lab kommer du arbeta med några enkla filter för endimensionella signaler. Du kommer att få implementera filtren från grunden som funktioner i Python, och testa dem på verkliga signaler och ljud.

## Hjälp och redovisning
För att få hjälp under labpasset, använd [Queue-systemet](http://queue.csc.kth.se/#/queue/DT1130) för att tillkalla Labassistent. För att få hjälp övrig tid, skriv ett inlägg under [Hjälp på Canvas](
  https://kth.instructure.com/courses/12513/discussion_topics/84209
  ).

När du är klar med labben behöver du göra två saker:
* Redovisa för en labassistent under ett labpass (använd [Queue-systemet](http://queue.csc.kth.se/#/queue/DT1130) för att meddela att du är klar att redovisa)
* Lämna in din lab som **.ipynb**-fil i Canvas (Ladda ner från Colab med **File | Download .ipynb**)

## Innan vi börjar
Det första man ska göra är att spara en egen kopia av detta labbpek då detta är skrivskyddat. Detta gör man antingen genom att klicka på open in playground eller *File* -> *Save a copy in drive*.

### Ladda in lite data

Hämta paketet med [labdata](https://www.dropbox.com/s/zwhbijy9k8t8u5x/labdata.zip?dl=1) om du inte redan gjort det. Det innehåller ljudfiler som du kan använda för att testa dina filter. Ladda in dem i Colab (Se [jobba med filer](https://colab.research.google.com/drive/1LoIS5JzeupGVf6a4-A0sBxAeOnxzdXW8?authuser=1#scrollTo=bmTBuKQMRoa_) i labintroduktionen)

### Ladda bibliotek

Slutligen behöver vi importera ett antal bibliotek som kommer ska användas under labben. Kör koden nedan för att göra det!
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.io import wavfile
from scipy import signal
from IPython.display import Audio

"""## Ett enkelt filter
Ett av de enklaste filtren vi kan tänka oss är ett rullande medelvärde. Ett rullande medelvärde är t.ex. användbart för utjämning  (eng "smoothing") av en brusig signal.

**Exempel: **

Ett rullande medlevärde av lägnden 3 över en sekvens $x(n)$ ges av

$$y(n) = \frac{x(n) + x(n-1) + x(n-2)}{3}$$

Det innebär i klartext att $y(n)$ är en sekvens där varje värde utgörs av medelvärdet av de tre senaste värdena  i $x(n)$. 

På samma sätt kan ett rullande medelvärde av längd $N$ skrivas som 

$$y(n) = \frac{1}{N}\sum_{k=0}^{N-1} x(n-k)$$

##Uppgift: Rullande medelvärde
Skriv en funktion `moving_average(N,X)` 

Funktionen ska beräkna ett rullande medelvärde av längd $N$ för insignalen $X$ där $N$ är ett heltal och $X$ är en array (`np.array`). Funktionen ska returnera en array av samma längd som $X$. Insignalen kan antas vara noll för alla negativa index.
"""

def moving_average(N,X):
  # En bra ide är att skapa en vektor för utsignalen
  # som har samma storlek som insignalen
  Y = np.zeros(X.shape)
  # Din kod här!
  for elem in range(len(X)):
    sum = 0
    for i in range(N):
      if elem - i < 0:
        sum += 0
      else:
        sum += X[elem - i]
    average = sum/N
    Y[elem] = average
  
  # algoritm:
  # 1. ta N antal värden från X vektorn och summera
  # 2. lägg till medelvärdet i Y vektorn
  # 3. upprepa tills X vektorn är slut (när Y är lika lång som X)

  return Y
vektor = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
moving_average(3, vektor)

"""**Testa funktionen** genom att filtrera en brusig sinussignal (se exempel på hur du generera den i labbintroduktionen) och plotta signalerna tillsammans. Använd samplings"""

# Test moving average 1

filter_length = 3    # @param {type: "slider", min: 1, max: 20}

# generera brusig sinuston - se labbintroduktion
# @title { run: "auto" }
samplingsfrekvens = 20000
tid = 1
frekvens = 535 #@param {type: "slider", min: 100, max: 1000}
t = np.linspace(0, tid, samplingsfrekvens * 2)
sinuston = np.sin(frekvens * 2 * np.pi * t)

# Och gör den uppspelningsbar
Audio(sinuston, rate=samplingsfrekvens)
# @title { run: "auto" }

# brusig sinussignal

brus = 50 #@param {type: "slider", min: 0, max: 100}

brus_intensitet = brus/100

## Skriv din kod nedan!


# skapa slumpvärden i samma storlek som "sinuston"
slumpvärden = np.random.randint(-1, 1, (40000,))*brus_intensitet

# Lägg till brus-datan genom att addera bruset med sinustonen
brusig_sinuston = sinuston + slumpvärden

utsignal = moving_average(filter_length,brusig_sinuston)

# plotta de första 300 samplen

plt.stem(brusig_sinuston[0:300]) 
plt.stem(utsignal[0:300],linefmt='red')

# lyssna 

Audio(utsignal, rate=samplingsfrekvens)

"""**Testa även** att filtrera en ljudfil!"""

# Test moving average 2

filter_length = 3    #@param {type: "slider", min: 1, max: 100}
fs,sound      = wavfile.read('speech1.wav')
filtered      = moving_average(filter_length,sound)

Audio(filtered,rate=fs)

"""##Faltning och FIR-filter

Ett filter utan återkoppling kallas även FIR-filter (FIR = Finite Impulse Response, filtret har ett ändligt impulssvar). 

**Exempel:**
Ett FIR-filter av längden 3 kan beskrivas med filterekvationen

$y(n) = b_0 x(n) + b_1 x(n-1) + b_2 x(n-2)$


Allmänt så ges ett filter av längden $N$ ges på motsvarande sätt av

$$y(n) = \sum_{k=0}^{N-1} b_k x(n-k)$$

Detta kallas för en faltningssumma, och skrivs ibland som $y(n) = \sum_{k=0}^{N-1} h(k) x(n-k)$

där $h(k)$ motsvarar filtretrs impulssvar. 

Filtrets funktion är alltså helt bestämd av de $N$ filterkoefficienterna $b_0, b_1 ...$ (För ett icke-återkopplat filter gäller som bekant att $h(n) = b_n$)

I praktiken kan vi representera filterkoefficienterna som en vektor $B$, vilket du kommer göra i uppgiften nedan.

### Idealt lågpassfilter

Hur ska man då veta vilka värden på $B$ man ska använda? Det finns många metoder för filterdesign - nedan beskrivs *en* metod, nämligen hur man kan approximera ett **idealt** lågpass (eller högpass-)filter. Du får färdiga python-funktioner nedan för detta, som du kan använda för att beräkna koefficienter till FIR-filtret du ska bygga.

**Ett idealt lågpassfilter** har förstärkningen *ett* under brytfrekvensen $f_c$ och *noll* ovanför. Ett sådant filter har ett impulssvar som ges av
$$h(n) = \frac{\sin(f_c \pi n)}{n\pi}$$ för $-\infty < n < \infty$

Funktionen $\frac{sin (\pi x)}{\pi x}$ förekommer ofta i signalbehandlingen kallas också en *sinc*-funktion (*sinus cardinalis*) och skrivs $sinc(x)$

**I praktiken** kan vi inte implementera ett idealt filter, eftersom det kräver ett **oändligt långt impulssvar**, som dessutom sträcker sig över negativa värden på tidsaxeln. Men vi kan approximera filtret genom att klippa av (trunkera) impulssvaret och förskjuta det till positiva delen av tidsaxeln.

Principen kan även avändas för att göra ett **högpassfilter**: Idén är att ta *skillnaden mellan ursprunglig signal och lågpassfiltrerad signal*. Vi kan skriva impulssvaret för detta filter genom att ta *skillnaden mellan en impuls och impulssvaret för lågpassfiltret*: 

$h_{hp}(n) = \delta(n) - h_{lp}(n)$

Nedanstående funktioner `ideal_lowpass(N,F)` och `ideal_highpass(N,F)` kan du använda för att skapa koefficienterna till ett sådant filter av längden $N$ med brytfrekvens $F$ (där $F = 1.0$ motsvarar halva samplingsfrekvensen dvs $\omega = \pi$).

Studera gärna hur funktionerna fungerar.
"""

# 'Ideal' low pass & high pass filter based on truncated sinc

def ideal_lowpass(N,F):
  n = np.arange(0,N)-(N-1)/2 # create time axis n from -(N-1)/2 to (N-1)/2 
  B = np.sinc(F*n)           # evaluate sinc function
                             # with freq F for all n
  B *= signal.hamming(N)     # multiply by hamming window
                             # to soften truncation 
  B /= np.sum(B)             # make total sum 1 (= unit gain at zero frequency)
  return B

def ideal_highpass(N,F):
  Blp = ideal_lowpass(N,F)        # get low-pass coefficients
                             # now create an impulse centered at (N-1)/2:
  Bhp = np.zeros(N)          # step 1: zero vector
  if N%2:                    # step 2 a (if N is odd): 
    Bhp[int((N-1)/2)]=1      #  set element at (N-1)/2 to one
  else:                      # step 2 b (if N is even):
    Bhp[int((N-1)/2)]=0.5    #  set elements at (N-1)/2 and (N-1)/2+1 to 0.5
    Bhp[int((N-1)/2+1)]=0.5
  Bhp = Bhp - Blp            # step 3: get the high-pass coefficients
                             #  by subtracting low-pass from impulse
  return Bhp                           

N = 31  #@param {type: "slider", min: 1, max: 49, step: 1}
F = 0.31 #@param {type: "slider", min: 0, max: 1.0, step: 0.01}

# plotta lågpass och högpass 
plt.subplot(1,2,1)
plt.stem(ideal_lowpass(N,F))
plt.subplot(1,2,2)
plt.stem(ideal_highpass(N,F),linefmt='red')

"""##Uppgift: FIR-filter 
Skriv en funktion som utför FIR-filtrering. Funktionen ska ta en array med filterkoefficienter $B$ och en array med värden $X$, och returnera en ny array med utsignalen från filtret.
"""

def fir_filter(B,X):
  Y = np.zeros(X.shape)
  for index in range(len(X)):
    sum = 0
    for koeff in range(len(B)):
      if index-koeff < 0:
        sum += 0
      else:
        sum += B[koeff]*X[index-koeff]
    Y[index] = sum
  return Y

"""### Testa FIR-filtret

Nu behöver du testa att FIR-filtret gör vad det ska

**Rullande medelvärde (igen)** Första testet är att återskapa filtret i första uppgiften: Ett rullande-medelvärdesfilter av längden $N$ är ju bara ett FIR-filter där alla koefficienter är satta till $\frac{1}{N}$, så skapa en sådan koefficient-array och kolla att du får samma resultat när du filtrerar en signal.
"""

# test av FIR-filter (rullande medelvärde)

B = np.ones(filter_length)/filter_length
X = brusig_sinuston
Y = fir_filter(B,X)
plt.plot(utsignal[0:305]) 
plt.plot(Y[0:300])

"""**Enkelt högpass** Ett högpassfilter karakteriseras av att summan av koefficienterna är noll. Ett enkelt högpassfilter ges av ekvationen $y(n) = x(n) - x(n-1)$. (dvs $b_0 = 1, b_1 = -1$). Testa detta filter med en ljudfil i din FIR-funktion. Hör du någon skillnad?"""

# test av FIR-filter (enkelt högpass)
fs, sound = wavfile.read('speech1.wav')
B = np.array((1,-1))
filtered = fir_filter(B,sound)
Audio(sound, rate = fs)
Audio(filtered, rate = fs)

"""**Idealt lågpass & högpass** Använd koden ovan för idealt lågpass och högpass. Filtrera en ljudfil och lyssna på resultatet för olika värden på filterlängd och brytfrekvens. Frekvensen ska vara i området 0-1 där 1 motsvarar nykvistfrekvensen $\frac{f_s}{2}$. Filterlängden kan göras ganska lång, storleksordningen några hundra sampel. Men det kan ta lång tid att filtrera långa ljud med långa filter.

Lyssna och jämför originalljudet med det filtrerade 

Testa även att sätta ett lågpass och högpass i serie*, där $F_{lågpass} > F_{högpass}$. Vad får du för filter nu?

*) ena filtrets utsignal blir det andras insignal
"""

N = 453  #@param {type: "slider", min: 1, max: 500, step: 2}
F_lp = 1 #@param {type: "slider", min: 0, max: 1.0, step: 0.01}
F_hp = 0.84 #@param {type: "slider", min: 0, max: 1.0, step: 0.01}

B_lp = ideal_lowpass(N,F_lp)
B_hp = ideal_highpass(N,F_hp)

fs,sound    = wavfile.read('speech1.wav')

# lågpass
Y_lp       = fir_filter(B_lp,sound)

# högpass
# Y_hp       = fir_filter(B_hp,sound)

serie = fir_filter(B_hp, Y_lp)

# slå ihop (concatenate) originalljud och filtrerat ljud
# så vi hör dem efter varandra

s = np.concatenate((sound, serie))
Audio(s,rate=fs)

"""## Överföringsfunktion och frekvenssvar

För att veta hur ett filter uppför sig i frekvensdomänen används överföringsfunktionen $H(z)$.

För FIR-filtret av längd 3  i exemplet ovan blir överföringsfunktionen 

$H(z) = b_0 + b_1 z^{-1} + b_2 z^{-2}$ och allmänt gäller för ett FIR-filter att


$$H(z) = \sum_{k=0}^{N-1}b_k z^{-k}$$

Med hjälp av överföringsfuntionen kan vi ta reda på filtrets frekvenssvar, dvs hur mycket filtret förstärker olika frekvenser. Detta görs genom att utvärdera beloppet av överföringsfunktionen över enhetscirkeln. I praktiken: sätt $z = e^{j\omega}$ och ta absolutbeloppet:

$$|H(\omega)| = \left|\sum_{k=0}^{N-1}b_k e^{-jk\omega}\right|$$

Man brukar plotta frekvenssvaret för $0 \leq \omega \leq \pi$

##Uppgift: Frekvenssvar för FIR


---


Skriv en funktion `fir_freqrespone(B,N)` som beräknar och plottar frekvenssvaret för ett FIR-filter för ett antal värden på $\omega$ mellan 0 och $\pi$.

Inparametrar är koefficientvektorn $B$, samt ett heltal $N$ som är antalet värden på $\omega$-axeln som ska beräknas (fördelade i intervallet $0 \le \omega \le \pi$). 

Eftersom du behöver jobba med komplexa tal kan det vara bra att repetera [det avsnittet i labintroduktionen](https://colab.research.google.com/drive/1LoIS5JzeupGVf6a4-A0sBxAeOnxzdXW8?authuser=2#scrollTo=qoYtuqlyW2AM&line=2&uniqifier=1)
"""

def fir_freqresponse(B,N):
  omega = np.arange(0, np.pi, np.pi/N)
  H = np.zeros(N)   # denna ska fyllas med |H(omega)|

  
  # skriv din kod här!
  for i in range(len(omega)):
    sum = 0
    z = np.e**(1j*omega[i])
    for j in range(len(B)):
      sum += B[j]*z**(-j)
    H[i] = abs(sum)


      
  plt.plot(omega, H)
  #return (H)

"""**Kör funktionen** för filtren i förra uppgiften (rullande medelvärde, högpass, idealt lågpass/högpass). Se vad som händer när du ändrar filterlängd, brytfrekvens etc."""

# test fir_freqresponse
fir_freqresponse(B, N)
fir_freqresponse(B_lp, N)
fir_freqresponse(B_hp, N)

"""## Återkoppling och IIR-filter

Ett återkopplat filter har en utsignal som beror av tidigare värden av *både insignalen och utsignalen*. 
Ett återkopplat filter kallas ibland IIR-filter (IIR = Infinite Impulse Response) eftersom impulssvaret kan ha oändlig utsträckning.

Ett IIR filter med $N$ fördröjningar kan beskrivas av en filterekvation (differensekvation):

$$y(n)=x(n) - \sum_{k=1}^Na_ky(n-k)$$

Samma filter beskrivs i frekvensdomänen ($z$-domänen) av överföringsfunktionen 

$$H(z) = \frac{1}{1+\sum_{k=1}^Na_kz^{-k}}$$

Nollställena för överföringsfunktionen nämnare kallas *poler* och polernas placering i z-planet avgör filtrets karakteristik.


### Tvåpolsresonator

En tvåplolsresonator är en enkel typ av återkopplat filter som beskrivs av överföringsfunktionen

$$H(z) = \frac{1}{(1-Re^{j\theta}z^{-1})(1-Re^{-j\theta}z^{-1})}$$

Den har två poler som befinner sig på avståndet $R$ från origo, med vinklarna $\pm\theta$ (Dessutom har den två nollställen i origo, men dessa påverkar inte frekvenssvaret.)

Tvåpolsresonatorn har ett frekvenssvar som består av en topp, vars läge i frekvensled bestäms av polvinkeln $\theta$, och toppens “spetsighet” bestäms av polradien $R$ (ju närmare $R$ är 1, desto spetsigare topp).
Impulssvaret hos en tvåpolsresonator kan beskrivas som en dämpad svängning, där graden av dämpning bestäms av $R$ - ju mindre $R$ desto mera dämpning får man. Specialfallet när $R = 1$, dvs polerna ligger på enhetscirkeln, ger en helt odämpad svängning dvs en oscillator. $R > 1$ ger ett instabilt filter.

##Uppgift: Resonator

Skriv om uttrycket för $H(z)$ ovan på formen

$$H(z) = \frac{1}{1 + a_1z^{-1} + a_2z^{-2} }$$ och uttryck $a_1$ och $a_2$ i termer av $R$ och $\theta$

Skriv sedan om detta till en filterekvation (differensekvation) med hjälp av [ekvationerna ovan](https://colab.research.google.com/drive/1FE9x9W5ZxRQbmWrAFCpMpToaRzfFWfRs?authuser=2#scrollTo=yEWKZIk0OOp-&line=26&uniqifier=1)

(Du ska alltså få ett uttrytck på formen 

$y(n) = ...x(n) ...y(n-1) ... y(n-2)$ som innehåller $R$ och $theta$)

Skriv slutligen en funktion som implementerar resonatorfiltret. Den ska ta in $R$, $theta$ samt en insignalvektor $X$ och returnera en utsignal $Y$.
`resonator(R,Theta,X)`
"""

def resonator(R,theta,X):
  Y = np.zeros(X.shape)
  a1 = R*(-np.e**(1j*theta)-np.e**(-1j*theta))
  a2 = R**2

  for i in range(len(X)):
    if i-1 < 0:
      Y[i] = X[i]
    elif i-2 < 0:
      Y[i] = X[i] - a1*Y[i-1]
    else:
      Y[i] = X[i] - a1*Y[i-1]- a2*Y[i-2]
  return Y



"""### Testa resonatorn

Nu ska du testa resonatorfunktionen så att du ser att den gör vad den ska

**Impulssvar** Börja med att generera ett impulssvar från ditt filter. Det gör du genom att skapa en impulsvektor $X = \begin{bmatrix}
  1 & 0 & 0 & 0 \dots
\end{bmatrix}$ och ge som insignal. Testa t.ex. med ett impulssvar av längden 50 och olika värdern på $R$ och $\theta$. Vad händer om $R=1$? Vad händer om $R>1$? Pröva dig fram tills du får en känsla för hur impulssvaret beror på $R$ och $\theta$.

*Exempel*: $R=0.95$ och $\theta = \frac{\pi}{8}$ bör ge något i stil med
![](https://drive.google.com/uc?export=download&id=1fZg597QAWVSCnSm17R3-jRIIRWkJBrax)
"""

# Test av IIR-filter - impulssvar

X = np.zeros(50)  # skapa en impulsvektor av längd 50
X[0] = 1

Y = resonator(0.9,np.pi/8,X)

plt.stem(Y)

"""**Kling & klang** Om du gör ett längre impulssvar (några tusen sampel) kan du *lyssna* på det. När $R$ är nära ett bör det bli tydliga klingande toner. För en ton med frekvensen $f$ sätter man $\theta = \frac{\pi f}{f_s}$"""

# Test av IIR-filter - 

fs = 16000   # samplingsfrekvens

X = np.ones(fs)
X[0] = 1  # skapa en impulsvektor av längd 'fs' (ger en sekund ljud)
f = 1829  #@param {type: "slider", min: 0, max: 4000}
R = 0.98 #@param {type:"slider",min:0.98, max:1.0, step:0.0001}
Y = resonator(0.999,np.pi*f/fs,X)

Audio(Y, rate=fs)

"""** italicized textFiltrera en ljudfil** slutligen kan du läsa in en ljudfil och applicera resonatorfiltret på denna. Testa med olika värden på $R$ och $\theta$ - beskriv vad som händer!"""

# Test av IIR-filter med ljudfil 
fs,X    = wavfile.read('acousticguitar.wav')

f = 1230 #@param {type: "slider", min: 0, max: 4000}

Y = resonator(0.999,np.pi*f/fs,X)

Audio(Y,rate=fs)

"""## Frekvenssvar för IIR-filtret

På samma sätt som i för FIR-filtret så kan vi räkna ut frekvenssvaret. Man utgår från överföringsfunktionen.

$$H(z) = \frac{1}{1+\sum_{k=1}^Na_kz^{-k}}$$

För ett tvåpolsfilter som resonatorn du byggt får vi det enklare uttrycket

$$H(z) = \frac{1}{1 + a_1z^{-1} + a_2 z^{-2}}$$


och går tillväga på samma sätt som vid [beräkning av frekvenssvaret för FIR-filtret](https://colab.research.google.com/drive/1FE9x9W5ZxRQbmWrAFCpMpToaRzfFWfRs?authuser=1#scrollTo=qfl-Z9etApHN&line=17&uniqifier=1), dvs man ansätter $z = e^{j\omega}$ och beräknar $|H(\omega)|$ för   $0 \le \omega \le \pi$

##Uppgift: Frekvenssvar för tvåpolsresonatorn


---

Skriv en funktion  `resonator_freqrespone(R,theta,N)` som beräknar och plottar frekvenssvaret för en tvåpolsresonator för ett antal värden på $\omega$ mellan 0 och $\pi$.

Inparametrar är $R$ och $\theta$ samt ett heltal $N$ som är antalet värden på $\omega$-axeln som ska beräknas (fördelade i intervallet $0 \le \omega \le \pi$). (funktionen kommer bli mycket lik den du gjorde för FIR-filtret)

**Kör funktionen**  för olika värden på $R$ och $\theta$ och plotta **både impussvar och frekvenssvar**
"""

def resonator_freqresponse(R,theta,N):
  omega = np.arange(0, np.pi, np.pi/N)
  a1 = R*(-np.e**(1j*theta)-np.e**(-1j*theta))
  a2 = R**2
  H = np.zeros(N)   # denna ska fyllas med |H(omega)|
  
  # skriv din kod här!
  for i in range(len(omega)):
    z = np.e**(1j*omega[i])
    sum = 1/(1 + a1*z**(-1) + a2*z**(-2))
    H[i] = abs(sum)

  plt.plot(H)
  return (H)



# testa resonator_freqresponse

H = resonator_freqresponse(0.99, np.pi/2, 512)

"""# Extrauppgift
Nu har du klarat av den obligatoriska delen av labben. Nedanstående kan du göra för att få högre betyg (och för att det är kul, såklart!)

## Uppgift (X): tidsvariabelt filter!

I denna uppgift ska du ta ett (eller flera) av filtren som du implementerat ovan och göra om implementationen så att det går att filterfunktionen kan ändras över tid! Det blir roligast om man testar det på ljudsignaler. 

**Exempel** 
* ett lågpassfilter där gränsfrekvensen går från noll till $\pi$ över loppet av insignalens längd. 
* en tvåpolsresonator där $\theta$ varierar enligt en långsam sinussvängning (ger en *Wah-wah-effekt* om man skickar in en gitarrsignal)

Rent praktiskt kan man lösa det på olika sätt - en möjlighet är att låta $\theta$  (i fallet för tvåpolsresonatorn) eller $F$ (i fallet med låg- eller högpassfiltret) vara en vektor med värden av samma längd som insignalen $X$. 

**Gör lite roliga ljudexempel** som ni kan spela upp vid redovisningen!
"""

N = 101  #@param {type: "slider", min: 1, max: 500, step: 2}
def ideal_lowpass(N,F):
  n = np.arange(0,N)-(N-1)/2 # create time axis n from -(N-1)/2 to (N-1)/2 
  B = np.sinc(F*n)           # evaluate sinc function
                             # with freq F for all n
  B *= signal.hamming(N)     # multiply by hamming window
                             # to soften truncation 
  B /= np.sum(B)             # make total sum 1 (= unit gain at zero frequency)
  return B

def fir_filter(X, N):
  Y = np.zeros(X.shape)
  F = np.arange(0, 1, 1/len(X))
  B = ideal_lowpass(N, F[0])

  for index in range(len(X)):
    sum = 0
    if index % 1000 == 0:
      B = ideal_lowpass(N, F[index])
    for koeff in range(len(B)):
      if index-koeff < 0:
        sum += 0
      else:
        sum += B[koeff]*X[index-koeff]
    #print(index)
    Y[index] = sum
  return Y

fs,sound    = wavfile.read("cantina.wav")
# lågpass
Y_lp       = fir_filter(sound, N)


# slå ihop (concatenate) originalljud och filtrerat ljud
# så vi hör dem efter varandra

s = np.concatenate((sound, Y_lp))
Audio(s,rate=fs)